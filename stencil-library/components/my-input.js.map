{"file":"my-input.js","mappings":";;AAAA,MAAM,UAAU,GAAG,sBAAsB,CAAC;AAC1C,sBAAe,UAAU;;MCSZA,SAAO;;;;;;;;;QAqGV,YAAO,GAAG,CAAC,EAAsB;YACvC,MAAM,KAAK,GAAG,EAAE,CAAC,MAAiC,CAAC;YACnD,IAAI,KAAK,EAAE;gBACT,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,IAAI,EAAE,CAAC;aAChC;YACD,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;SAC1B,CAAC;QAEM,aAAQ,GAAG,CAAC,EAAS;YAC3B,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;SAC1B,CAAC;QAEM,WAAM,GAAG,CAAC,EAAc;YAC9B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SACtB,CAAC;QAEM,YAAO,GAAG,CAAC,EAAc;YAC/B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;SACvB,CAAC;wBA/GiB,KAAK;wBAKL,KAAK;oBAKE,MAAM;qBAK0B,EAAE;;;;;IA0ClD,YAAY;QACpB,MAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;QACrC,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC9B,IAAI,WAAW,IAAI,WAAW,CAAC,KAAK,KAAK,KAAK,EAAE;YAC9C,WAAW,CAAC,KAAK,GAAG,KAAK,CAAC;SAC3B;KACF;;;;;;;IAQO,eAAe,CAAC,KAAa;QACnC,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;;QAEvB,MAAM,QAAQ,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;QAC1D,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,QAAe,EAAE,KAAK,EAAE,CAAC,CAAC;KACvD;;;;IAKO,eAAe,CAAC,KAAa;QACnC,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC;;QAGvB,MAAM,QAAQ,GAAG,KAAK,IAAI,IAAI,GAAG,KAAK,GAAG,KAAK,CAAC,QAAQ,EAAE,CAAC;QAC1D,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,QAAe,EAAE,KAAK,EAAE,CAAC,CAAC;KACtD;IAEO,QAAQ;QACd,OAAO,OAAO,IAAI,CAAC,KAAK,KAAK,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,CAAC,IAAI,CAAC,KAAK,IAAI,EAAE,EAAE,QAAQ,EAAE,CAAC;KAC/F;IAsBO,WAAW;QACjB,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;QAC1B,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAE9B,QACE,EAAC,IAAI,QACH,aACE,GAAG,EAAE,KAAK,KAAK,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,EACxC,QAAQ,EAAE,QAAQ,EAClB,QAAQ,EAAE,IAAI,CAAC,QAAQ,EACvB,IAAI,EAAE,IAAI,CAAC,IAAI,EACf,KAAK,EAAE,KAAK,EACZ,OAAO,EAAE,IAAI,CAAC,OAAO,EACrB,QAAQ,EAAE,IAAI,CAAC,QAAQ,EACvB,MAAM,EAAE,IAAI,CAAC,MAAM,EACnB,OAAO,EAAE,IAAI,CAAC,OAAO,GACrB,CACG,EACP;KACH;IAED,MAAM;QACJ,OAAO,IAAI,CAAC,WAAW,EAAE,CAAC;KAC3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","names":["MyInput"],"sources":["src/components/my-input/my-input.css?tag=my-input&encapsulation=shadow","src/components/my-input/my-input.tsx"],"sourcesContent":[":host {\n  display: block;\n}\n","import type { EventEmitter } from '@stencil/core';\nimport { Component, Element, Event, Host, Prop, Watch, h } from '@stencil/core';\nimport type { InputChangeEventDetail, InputInputEventDetail } from './input-interface';\nimport { InputType } from './input-type';\n\n@Component({\n  tag: 'my-input',\n  styleUrl: 'my-input.css',\n  shadow: true,\n})\nexport class MyInput {\n  private nativeInput?: HTMLInputElement;\n\n  @Element() el!: HTMLMyInputElement;\n\n  /**\n   * If `true`, the user cannot interact with the input.\n   */\n  @Prop() disabled = false;\n\n  /**\n   * If `true`, the user must fill in a value before submitting a form.\n   */\n  @Prop() required = false;\n\n  /**\n   * The type of control to display. The default type is text.\n   */\n  @Prop() type: InputType = 'text';\n\n  /**\n   * The value of the input.\n   */\n  @Prop({ mutable: true }) value?: string | number | null = '';\n\n  /**\n   * The `myInput` event is fired each time the user modifies the input's value.\n   * Unlike the `myChange` event, the `myInput` event is fired for each alteration\n   * to the input's value. This typically happens for each keystroke as the user types.\n   *\n   * For elements that accept text input (`type=text`, `type=tel`, etc.), the interface\n   * is [`InputEvent`](https://developer.mozilla.org/en-US/docs/Web/API/InputEvent); for others,\n   * the interface is [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event). If\n   * the input is cleared on edit, the type is `null`.\n   */\n  @Event() myInput!: EventEmitter<InputInputEventDetail>;\n\n  /**\n   * The `myChange` event is fired when the user modifies the input's value.\n   * Unlike the `myInput` event, the `myChange` event is only fired when changes\n   * are committed, not as the user types.\n   *\n   * Depending on the way the users interacts with the element, the `myChange`\n   * event fires at a different moment:\n   * - When the user commits the change explicitly (e.g. by selecting a date\n   * from a date picker for `<my-input type=\"date\">`, pressing the \"Enter\" key, etc.).\n   * - When the element loses focus after its value has changed: for elements\n   * where the user's interaction is typing.\n   */\n  @Event() myChange!: EventEmitter<InputChangeEventDetail>;\n\n  /**\n   * Emitted when the input loses focus.\n   */\n  @Event() myBlur!: EventEmitter<FocusEvent>;\n\n  /**\n   * Emitted when the input has focus.\n   */\n  @Event() myFocus!: EventEmitter<FocusEvent>;\n\n  /**\n   * Update the native input element when the value changes\n   */\n  @Watch('value')\n  protected valueChanged() {\n    const nativeInput = this.nativeInput;\n    const value = this.getValue();\n    if (nativeInput && nativeInput.value !== value) {\n      nativeInput.value = value;\n    }\n  }\n\n  /**\n   * Emits an `myChange` event.\n   *\n   * This API should be called for user committed changes.\n   * This API should not be used for external value changes.\n   */\n  private emitValueChange(event?: Event) {\n    const { value } = this;\n    // Checks for both null and undefined values\n    const newValue = value == null ? value : value.toString();\n    this.myChange.emit({ value: newValue as any, event });\n  }\n\n  /**\n   * Emits an `myInput` event.\n   */\n  private emitInputChange(event?: Event) {\n    const { value } = this;\n\n    // Checks for both null and undefined values\n    const newValue = value == null ? value : value.toString();\n    this.myInput.emit({ value: newValue as any, event });\n  }\n\n  private getValue(): string {\n    return typeof this.value === 'number' ? this.value.toString() : (this.value || '').toString();\n  }\n\n  private onInput = (ev: InputEvent | Event) => {\n    const input = ev.target as HTMLInputElement | null;\n    if (input) {\n      this.value = input.value || '';\n    }\n    this.emitInputChange(ev);\n  };\n\n  private onChange = (ev: Event) => {\n    this.emitValueChange(ev);\n  };\n\n  private onBlur = (ev: FocusEvent) => {\n    this.myBlur.emit(ev);\n  };\n\n  private onFocus = (ev: FocusEvent) => {\n    this.myFocus.emit(ev);\n  };\n\n  private renderInput() {\n    const { disabled } = this;\n    const value = this.getValue();\n\n    return (\n      <Host>\n        <input\n          ref={input => (this.nativeInput = input)}\n          disabled={disabled}\n          required={this.required}\n          type={this.type}\n          value={value}\n          onInput={this.onInput}\n          onChange={this.onChange}\n          onBlur={this.onBlur}\n          onFocus={this.onFocus}\n        />\n      </Host>\n    );\n  }\n\n  render() {\n    return this.renderInput();\n  }\n}\n"],"version":3}